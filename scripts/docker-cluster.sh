#!/bin/bash
#
# This script provides an intelligent, non-destructive way to start the Docker cluster.
# It checks for port availability and finds free ports if the defaults are taken.
#

set -e

COMPOSE_CMD=${COMPOSE_CMD:-"docker compose"}

# --- Helper Functions ---
info() {
    echo "INFO: $1"
}

# Track ports we reserved during this run so subsequent lookups stay unique.
declare -a USED_PORTS=()

reserve_port() {
    local var_name="$1"
    local port=$2

    while true; do
        if lsof -i:"$port" >/dev/null 2>&1; then
            port=$((port + 1))
            continue
        fi

        local already_assigned=false
        for used in "${USED_PORTS[@]}"; do
            if [[ "$used" -eq "$port" ]]; then
                already_assigned=true
                break
            fi
        done

        if [[ "$already_assigned" == false ]]; then
            USED_PORTS+=("$port")
            printf -v "$var_name" '%s' "$port"
            return
        fi

        port=$((port + 1))
    done
}

# --- Port Configuration ---
info "Checking port availability and creating .env file..."
ENV_FILE=".env"
echo "# This file is auto-generated by docker-cluster.sh" > $ENV_FILE

DEFAULT_GATEWAY_API_PORT=10000
DEFAULT_ORCHESTRATOR_PORT=10001
DEFAULT_IDENTITY_SERVICE_PORT=10002
DEFAULT_REDIS_PORT=10003

reserve_port GATEWAY_API_PORT $DEFAULT_GATEWAY_API_PORT
reserve_port ORCHESTRATOR_PORT $DEFAULT_ORCHESTRATOR_PORT
reserve_port IDENTITY_SERVICE_PORT $DEFAULT_IDENTITY_SERVICE_PORT
reserve_port REDIS_PORT $DEFAULT_REDIS_PORT

echo "GATEWAY_API_PORT=${GATEWAY_API_PORT}" >> $ENV_FILE
echo "ORCHESTRATOR_PORT=${ORCHESTRATOR_PORT}" >> $ENV_FILE
echo "IDENTITY_SERVICE_PORT=${IDENTITY_SERVICE_PORT}" >> $ENV_FILE
echo "REDIS_PORT=${REDIS_PORT}" >> $ENV_FILE

ensure_network() {
    local network_name="somaagenthub-network"
    local compose_label="somaagenthub-network"

    if docker network inspect "${network_name}" >/dev/null 2>&1; then
        local existing_label
        existing_label=$(docker network inspect -f '{{ index .Labels "com.docker.compose.network" }}' "${network_name}" 2>/dev/null || true)
        if [[ "${existing_label}" != "${compose_label}" ]]; then
            info "Removing stale network ${network_name} (label mismatch)..."
            docker network rm "${network_name}" >/dev/null 2>&1 || true
        fi
    fi
}

ensure_network

# --- Start Docker Compose ---
info "Starting the Docker cluster in the background..."
${COMPOSE_CMD} up --build -d

# --- Health Verification ---
wait_for_http_service() {
    local service_name="$1"
    local url="$2"
    local attempts=${3:-30}
    local sleep_seconds=${4:-2}

    for ((i = 1; i <= attempts; i++)); do
    if python -c "import urllib.request; urllib.request.urlopen('${url}', timeout=3)" >/dev/null 2>&1; then
            info "${service_name} is healthy (${url})."
            return 0
        fi
        sleep "${sleep_seconds}"
    done

    echo "ERROR: ${service_name} did not report healthy state at ${url} within expectations." >&2
    ${COMPOSE_CMD} logs "${service_name}" | tail -n 25 || true
    return 1
}

wait_for_redis() {
    local attempts=${1:-30}
    local sleep_seconds=${2:-2}

    for ((i = 1; i <= attempts; i++)); do
    if ${COMPOSE_CMD} exec -T redis redis-cli ping >/dev/null 2>&1; then
            info "redis is healthy (PING)."
            return 0
        fi
        sleep "${sleep_seconds}"
    done

    echo "ERROR: redis did not respond to PING within expectations." >&2
    ${COMPOSE_CMD} logs redis | tail -n 25 || true
    exit 1
}

wait_for_temporal() {
    local attempts=${1:-40}
    local sleep_seconds=${2:-3}

    for ((i = 1; i <= attempts; i++)); do
    if ${COMPOSE_CMD} exec -T temporal-server tctl --address temporal-server:7233 cluster health >/dev/null 2>&1; then
            info "temporal-server is healthy (tctl cluster health)."
            return 0
        fi
        sleep "${sleep_seconds}"
    done

    echo "ERROR: temporal-server did not report healthy state via tctl." >&2
    ${COMPOSE_CMD} logs temporal-server | tail -n 50 || true
    exit 1
}

wait_for_redis
wait_for_temporal
wait_for_http_service "identity-service" "http://127.0.0.1:${IDENTITY_SERVICE_PORT}/ready" || exit 1
wait_for_http_service "orchestrator" "http://127.0.0.1:${ORCHESTRATOR_PORT}/ready" || exit 1
if ! wait_for_http_service "gateway-api" "http://127.0.0.1:${GATEWAY_API_PORT}/healthz"; then
    echo "WARNING: gateway-api health endpoint did not respond; continuing for inspection." >&2
fi

# --- Report Status ---
info "Docker cluster is running. Port assignments:"
echo "+------------------+----------------+"
echo "| Service          | Port           |"
echo "+------------------+----------------+"
printf "| gateway-api      | %-14s |\n" $GATEWAY_API_PORT
printf "| orchestrator     | %-14s |\n" $ORCHESTRATOR_PORT
printf "| identity-service | %-14s |\n" $IDENTITY_SERVICE_PORT
printf "| redis            | %-14s |\n" $REDIS_PORT
echo "+------------------+----------------+"
